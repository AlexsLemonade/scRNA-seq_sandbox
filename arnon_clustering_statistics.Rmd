---
title: "Clustering Statistics"
author: "C. Savonen CCDL for ALSF"
date: "12/17/2018"
output: html_document
---
### Purpose: compare normalization methods for a Arnon et al dataset

Install necessary packages: 
```{r Get packages }
# Load in functions
source(file.path("scripts", "CZI_functions.R"))

# These are the necessary packages
packages <- c("Rtsne", "NMI", "caret")

# Check if these packages are installed and install them if they aren't
lapply(packages, function(package) {
  if (!(package %in% installed.packages())) {
    install.packages(package)
  }
})
```

Import data that was previously obtained from submitting counts that were formatted
by `arnon_asap_data_prep.Rmd` to [ASAP](https://asap.epfl.ch/)
```{r Import data}
# Get the file names of all the normalized files
normalized.files <- dir("arnon_data/normalized_arnon")

# Read in each of the normalization files
normalized.data <- lapply(normalized.files, function(file) {
                              readr::read_tsv(file.path("arnon_data/normalized_arnon",
                                                        file))
                          })

# Keep all the gene lists
genes <- lapply(normalized.data, function(x) x[,1])

# Keep the names with it.
names(normalized.data) <- gsub("\\.tab|arnon_", "", normalized.files)
```

Import the metadata: 
```{r Metadata set up}
# Read in the data
meta <- readr::read_csv(file.path("arnon_data", "meta_data.csv"))
```

Retrieve cell type and plate batch for these samples:
```{r Retrieve cell type and plate batch for these samples}
# Get sample names from columns
samples <- colnames(normalized.data[[1]])[-1]

# Keep metadata only for the samples we have
meta <- meta[match(samples, meta$title), ]

# Extra cell types info as it's own vector
cell.types <- as.factor(meta$cell.type.ch1)
plate.batch <- as.factor(meta$cohort.ch1)
```

Run tsne clustering for each dataset:
```{r Make clusters with tsne}
# Run tsne on each dataset and extract
tsne <- lapply(normalized.data, function(dat) {
                        tsne.res <- Rtsne::Rtsne(t(dat[,-1]),
                                                 check_duplicates = FALSE)
                        tsne.res <- tsne.res$Y
                        names(tsne.res) <- samples
                        return(tsne.res)
                        })
```

Plot all the tsne's for all the datasets with labeling with batch info as well as 
cell type info. 
```{r Make function to plot tsne}
# Make a function to plot the tsne datasets
tsne.plot <- function(dat, var, name = "name"){
  # This function is to plot tsne data and label it by a variable
  # Args:
  #  dat: a data.frame with two columns of data
  #  var: vector contains metadata labels
  #  name: a character string for the plot title and for to save as png
  # Returns:
  #   png and plot in Rmd of the provided data with labels of the metadata provided
  # convert celltype into numbers
  colz <- colors(distinct = TRUE)[runif(length(levels(var)), min = 1,
                                        max = length(colors(distinct = TRUE)))]
  plot(dat, pch = 21, bg = colz[var], main = name, ylab = "tsne dim 2",
       xlab = "tsne dim 1");
  legend(x = "bottomleft", legend = levels(var), fill = colz, cex = 0.6)
}
```

Plot all the tsnes
```{r Plot the tsne}
# Plot each dataset with cell type and plate batch labels
lapply(tsne, function(dataset) {
      # Get normalization method
      set.name <- names(tsne)[parent.frame()$i[]]
      
      # Make plots for cell type and plate batch 
      cell.type.plot <- tsne.plot(dataset, var = cell.types, name = set.name)
      plate.batch.plot <- tsne.plot(dataset, var = plate.batch, name = set.name)
    
      # Save the plots to pngs
      png(paste0("tsne_", set.name, "cell_type.png"))
      cell.type.plot
      dev.off()
      
      png(paste0("tsne_", set.name, "plate_batch.png"))
      plate.batch.plot
      dev.off()
      
      # Print out the plots in the Rmd
      cell.type.plot
      plate.batch.plot
})

```

Make a function to do kmeans clustering and obtain Normalized Mutual Information
"nmi"and Adjusted Rand Index "ari" statistics over 10 iterations. 
```{r kmeans stats function}
kmeans_eval <- function(feature, metadata = metadata, iter = 10) {
  # This function is used to perform iterative k-means clustering based on projected 
  # features for single cell data and then evaluate the performance according to 
  # Normalized mutual information (NMI) and adjusted rand index (ARI)
  #
  # Args:
  #  feature: a data.frame contains clustering dimensions
  #  metadata: vector contains cell type or other metadata information
  #  iter: number of interation for k-means clustering
  # Returns:
  #   NMI and ARI results
  #   
  # Convert celltype into numbers
  metadata_num <- as.numeric(factor(metadata))
  sample_id <- seq(1:nrow(feature))
  
  # iterative k-means
  nmi_score_all <- c()
  ari_score_all <- c()
  all_cluster <- list()
  
  for(i in 1:iter){
    # set k equal to the number of celltypes in the dataset
    k <- length(unique(metadata))
    
    # perform k means clustering
    km <- kmeans(feature, k)

    # true clusters
    orignal_data <- data.frame(sample_id, metadata_num)
    
    # predicted clusters
    cl_data <- data.frame(sample_id, km$cluster)
    
    # calculate NMI and ARI score
    nmi_score <- NMI::NMI(orignal_data, cl_data)$value
    ari_score <- mclust::adjustedRandIndex(km$cluster, metadata_num)
    
    nmi_score_all <- c(nmi_score_all, nmi_score)
    ari_score_all <- c(ari_score_all, ari_score)
  }

  # Compile all results into a data.frame
  results <- data.frame(ari = ari_score_all, nmi = nmi_score_all)
  return(results)
}
```

Make a function to do K nearest neighbor clustering and obtain accuracy scores 
over iterations (default is 10)
```{r KNN eval function}
knn_eval <- function(feature, metadata = metadata, iter = 10){
  # This function performs knn based evaluation 
  # Args:
  #  feature: a data.frame contains clustering dimensions
  #  metadata: vector contains cell type or other metadata information  
  #  iter: number of interation for knn clustering
  # Returns:
  #  list of accuracy scores for each iteration of KNN
  
  # Make the data into a data.frame:
  feature <- data.frame("tsne" = feature, "metadata" = metadata)
  
  # Split observations into groups
  cv <- cvTools::cvFolds(nrow(feature), K = iter, R = 1)
  
  # Create empty objects to store the performance information for each iteration
  perf.eval <- list()
  confusion.matrix <- 0
  
  # Go through this iteration that k times
  for (i in 1:iter) {
    # Isolate samples for training the model
    train <- feature[cv$subsets[-which(cv$which == i)], ]
    
    # Isolate samples for testing the model
    test <- feature[cv$subsets[which(cv$which == i)], ]
    
    # Perform KNN model fitting
    knn.fit <- caret::train(metadata~. , data = train, method = "knn",
                     trControl = caret::trainControl(method = "cv", number = 3),
                     preProcess = c("center", "scale"),
                     tuneLength = 10)
    
    # Evaluate the model
    knn.pred <- predict(knn.fit, newdata = subset(test, select = -c(metadata)))
    perf.eval[[i]] <- round(cal_performance(knn.pred, test$metadata, 3), 2)
    
    # Make the results into a matrix
    matrix <- as.matrix(table(test$metadata, knn.pred, deparse.level = 0))
    confusion.matrix <- matrix + confusion.matrix
  }
  
  # Get mean performance of cross validation
  perf.eval <- dplyr::bind_rows(perf.eval)
  accuracy <- perf.eval$accuracy

  return(data.frame("knn" = accuracy))
}
```

Run cell type analyses on all the tsne datasets
```{r Run cell type analyses}
# Get knn and kmeans results for all tsne's of all datasets
cell.type.results <- lapply(tsne, function(dataset) {
                        # Get clustering results of the data
                        knn.results <- knn_eval(dataset, metadata = cell.types)
                        kmeans.results <- kmeans_eval(dataset, metadata = cell.types)
                            
                        # Return data frame of combined results
                        data.frame(knn.results, kmeans.results)
                            })
```

Run plate batch analyses on all the tsne datasets
```{r Run batch analyses}
# Get knn and kmeans results for all tsne's of all datasets
batch.results <- lapply(tsne, function(dataset) {
                        # Get clustering results of the data  
                        knn.results <- knn_eval(dataset, metadata = plate.batch)
                        kmeans.results <- kmeans_eval(dataset,
                                                      metadata = plate.batch)
                          
                        # Return data frame of combined results  
                        data.frame(knn.results, kmeans.results)
                        })
```

Set up a function for formatting the data into ggplot2 and subseuently plot the 
data
```{r Format data for ggplot2}
plot.results <- function(results.list, name = "results") {
  # This function makes a boxplot of the cluster statistic results 
  # Args:
  #  results.list: a list of dataframes which each column contains a different 
  #                statistic for 10 iterations
  #  name: name to use for the png to be saved and the plot title 
  # Returns: boxplots of the normalization method cluster statistics. Prints the
  #          plots and save the plot as a png
  # Get meta info 
  meta <- names(unlist(results.list))

  # Transform list into a dataframe:
  ggplot.df <- data.frame("method" = stringr::word(meta, 1, sep = "\\."),
                          "test" = gsub("[0-9]*$", "", 
                                               stringr::word(meta, 2, sep = "\\.")),
                          "iter" = rep(1:10, length(results.list)*3),
                          "values" = unlist(results.list))
  
  # Make the plot
  plot <- ggplot(data = ggplot.df, aes(x = method, y = values, fill = test)) +
          geom_boxplot(position = position_dodge()) + 
          xlab("Normalization method") +
          ggtitle(name) +
          facet_wrap(~test)

  # Save plot to png
  ggsave(paste0(name, "cluster_results.png"), width = 10) 
  
  # Print plot
  plot
}
```

Plot all the statistics on a boxplot
```{r Print the plots}
# Plot the cell type results 
plot.results(cell.type.results, name = "Cell_type")

# Plot the plate batch results
plot.results(batch.results, name = "Plate_batch")
```

Session info: 
```{r}
sessionInfo()
```